前面说到了静态链接，当目标文件引用了其他模块的变量或者函数的时候，在链接前会将符号做一个标记，生成符号重定位表然后在真正链接的时候将真正的地址写入到目标文件，这样就形成了最后的可执行文件。但是一个程序最终要能够运行，可执行文件中的程序和数据必须在内存中才能够正常运行

由于物理内存是昂贵的，并且发现了程序局部性原理，所以在将程序装入内存的时候只是将运行该程序必要的数据写入内存中，而一些不必要的数据则留在磁盘中，然后根据一些页淘汰算法进行页的更新，最典型的方法就是页映射

# 页映射

页映射需要将内存中的数据和磁盘中的数据按照页为单位划分为若干个页，现在假设我们有一个程序是32k的但是内存只有16k能够使用，我们的机器是32位的每个页的大小为4096个字节，那么16k则一共有4个页

![image-20211109153908797](http://cdn.noteblogs.cn/image-20211109153908797.png)

由于我们的程序和数据总和为32k，那么程序一共分为8个页编号为P0-P7，很显然16kb的内存是无法一次性将32k的程序装入内存内的，那么它的装载过程如下 ：如果程序刚开始执行时的入口地址在PO，这时装载管理器（我们假设装载过程由一个叫装载管理器的家伙来控制，就像覆盖管理器一样)发现程序的PO不在内存中，于是将内存F0分配给PO，并且将PO的内容装入F0；运行一段时间以后，程序需要用到P5，于是装载管理器将P5装入F1；就这样，当程序用到P3和P6的时候，它们分别被装入到了F2和 F3，它们的映射关系如图所示

![image-20211109154305333](http://cdn.noteblogs.cn/image-20211109154305333.png)

当运行过程中需要访问其他页的时候，可以采取一些页面置换算法将内存中的一些页淘汰掉，然后将需要的页面置换进行内存中这样程序得以运行

# 从操作系统角度看可执行文件的装载

### 进程的建立

在操作系统的角度，一个进程关键的特征是拥有独立的虚拟地址空间，一个程序被执行的同时都伴随着一个新的进程的创建，一般来说只需要下面三个步骤：

- 创建一个独立的虚拟地址空间，创建一个虚拟的地址空间并不是真正的创建空间而是创建映射函数所需要的相应的数据结构，通过这个数据结构将虚拟地址空间与真正的物理空间联系起来
- 读取可执行文件头，并且创建虚拟空间与可执行文件的映射关系，这一步做的是虚拟空间与可执行文件的映射关系，意义上来说这才是装载的过程
- 将CPU指令寄存器设置成为可执行文件的入口，然后启动运行

### 页错误

执行完上面的步骤，可执行文件的真正指令和数据都没有被装入到内存中，只是建立起来了可执行文件到虚拟内存和虚拟内存到真正的物理内存之间的映射关系。假设程序的入口地址是0x08048000，当CPU开始执行这个可执行文件入口地址的时候，发现0x08048000 ~ 0x08049000是一个空页面，所以发生页错误，CPU将控制权交给操作系统，操作系统有专门的页错误进程来处理这个情况，操作系统将查询上面第二步建立的数据结构，找到空页面的VMA(虚拟内存地址)，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后在将控制权还给进程，接着从刚才发生页错误的位置重新开始执行

# 进程虚存空间分布

这里有一个问题，可执行文件映射到虚拟内存空间的时候，是按页映射的如果可执行文件的某个段不足一个页那么将会进行页的对齐，当可执行文件这种比较小的段的数量比较多的时候就会造成空间的浪费，一般来说在可执行文件里面一般有以下几种段类型：

- 以代码段为代表的权限为可读可执行的段
- 以数据段和BSS段为代表的权限可读可写的段
- 以只读数据段为代表的权限为只读的段

解决上述的内存浪费问题可以将对于相同权限的段把它们合并到一起当做一个段进行映射，在ELF目标文件中我们是按照段的概念说的，其实这个段的概念是节的，就是目标文件本身是一个一个节的，但是到了目标文件需要将一些节进行合并这是真正的段的概念，例如.text和.init节合并到一个“Segment”，那么在进程虚拟空间中只有一个相对应的VMA，这样的话很明显的减少内存碎片节省空间

