# 一、Linux下的网络I/O模型

所谓I/O就是输入与输出，而网络I/O就是两个应用程序之间进行的通信，而I/O模型就是表明了使用什么的通道进行数据的发送和接收。I/O模型的很大程度上决定了程序通信的性能。linux中有五种I/O模型，下面一一介绍

### 1.1 应用A,B通信过程

学过计算机网络的同学就知道，计算机网络中有五层模型，当A向B发送数据的时候，必须要封装对应层次的数据报文，简单来说，A向B发送数据会经过下面几个流程

![image-20210114134206319](http://cdn.noteblogs.cn/image-20210114134206319.png)

1. 应用进程A组装好TCP格式报文，并将数据发送到TCP发送缓冲区
2. TCP发送缓冲区将数据发送到下一层传输层
3. 数据在传输层封装好对应的IP数据报文，将数据传入下一层
4. 物理层封装MAC地址发送目标地址
5. 应用B收数据过程相反

可以看出，要想接收或者发送数据会经过TCP缓冲区，那么其实这里就可以引出阻塞和非阻塞，当一个应用从TCP缓冲区里读数据的时候，如果缓冲区为空时要一直等待呢？还是返回？(写数据一样的问题，当缓冲区满时是等缓冲区为空，还是返回？，下文统一举例读数据的例子)

### 1.2 阻塞IO

阻塞IO可以理解为当应用要读取数据时，如果缓冲区为空，也就是内核数据没有准备好的·时候，应用处于一直等待的状态，也就是阻塞知道内核将数据准备好了，应用才结束。

**阻塞IO：在应用调用recvfrom读取数据时，其系统调用直到数据包到达并且被复制到应用缓冲区中或者发生错误时才返回，==在此期间一直会等待==，进程从调用到返回这段时间内都是被阻塞的称为阻塞IO。**

![image-20210114170741956](http://cdn.noteblogs.cn/image-20210114170741956.png)

阻塞IO的工作流程为：

1. 应用程序向内核发起recvfrom读取数据
2. 内核准备数据包，在这个过程中，进程处于阻塞状态，一直等待数据
3. 内核将数据包准备好且复制到应用空间
4. 返回成功提示，应用进程读取数据报



### 1.3 非阻塞IO

有了阻塞IO的知识，那么理解非阻塞IO就简单了，非阻塞IO就是说，当应用进程要读取数据时，发现内核数据并没有准备好，那么应用即刻返回，并不会让应用进程一直在等待。

**非阻塞IO是在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，==不会让应用一直等待中==。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用recvfrom请求，直到读取到它数据要的数据为止。**

![image-20210114171559056](http://cdn.noteblogs.cn/image-20210114171559056.png)

非阻塞IO流程：

1. 应用进程向内核发起recvfrom调用准备读取数据
2. 内核数据没有准备好，即刻返回EWOULDBLOCK错误
3. 应用进程不断向内核发起ecvfrom调用
4. 如果内核数据报已经准备好进行下一步，如果没有继续返回错误
5. 将数据从内核拷贝到用户空间

### 1.4 IO多路复用

以上分析的情况都是在单线程或者并发量很小的情况下，但是如果说是在高并发的情况下，那么如果有多个人向应用发送请求，那么应用进程就要开多个线程，每个线程都调用recvfrom函数去读取数据，即使是非阻塞的也要多个线程去不断查询数据是否准备好，而线程是非常宝贵的资源，如果在高并发下有几百几千甚至更多，那么后果可想而知要开出几百几千的线程，服务器的压力将会大幅度增大。所以为了解决这个问题，提出了多路复用模型

![image-20210114191044507](http://cdn.noteblogs.cn/image-20210114191044507.png)

首先，了解一个概念，fd文件描述符：内核)（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。可以这么理解，当有一个请求过来时，linux内核将这个请求以一个fd来标识

那么多路复用模型可以大致用下图来模拟

![image-20210114191805751](http://cdn.noteblogs.cn/image-20210114191805751.png)

IO复用模型提供了select、poll、epoll函数来监控系统内核中的数据是否已经准备好，如果准备好了那么将会通知处理数据的线程，对应的线程将会发起recvfrom请求去读取数据

进程通过将一个或多个fd传递给select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据。

![image-20210114192039833](http://cdn.noteblogs.cn/image-20210114192039833.png)

### 1.5 信号驱动式IO模型

IO多路复用解决了一个在高并发情况下一个线程监控多个fd的问题，并且是通过轮询的方式来监控多个fd，但是在真实情况下，这种轮询大多数都是无效的，所以又提出了另外一个问题：可不可以当系统内核的数据一旦已经准备好就通知select线程呢？而不是要我一个一个的去询问，那么在这个背景下就产生了信号驱动式IO模型

![image-20210114193130422](http://cdn.noteblogs.cn/image-20210114193130422.png)

首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据。

![image-20210114193219906](http://cdn.noteblogs.cn/image-20210114193219906.png)

综上，信号驱动模型通过建立这种关联信号的方式，实现发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态状态轮询操作

### 1.6 异步IO

IO多路复用和信号驱动式IO模型在性能上有了大幅度的提高，但是还有一个缺点，要发起一个阻塞式的select询问数据状态的请求，有没有办法可以不发出这种询问式的查询请求，当应用向内核发送一个我需要数据的请求，然后就不需要其他操作了，系统当数据准备好的时候发起一个通知告诉应用

![image-20210114194752747](http://cdn.noteblogs.cn/image-20210114194752747.png)

 应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。

![image-20210114194843385](http://cdn.noteblogs.cn/image-20210114194843385.png)

### 1.7 总结

**通过上面五种模型，知道所谓阻塞与非阻塞，就是在发起数据请求时，当数据还没准备好的时候，是一直等呢还是返回？所谓异步与同步，就是发起数据请求时，是不是从数据请求到数据彻底的接收完成这一整个过程都需要自己参与，还是应用只是发出一个需要读取数据的指令后就不管了？**

# 二、Java的IO模型

Java一共支持3中网络模型编程：BIO、NIO、AIO，这些IO是对上面五种IO模型的一个封装，所以理解了上述Linux下的IO模型，那么Java中的三种IO模型也很好理解

### 2.1 BIO

同步并阻塞IO(传统IO模型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端需要启动一个线程进行处理，这样就会导致如果这个连接不做任何事情，只是在等待客户端的消息那么就会造成浪费

![image-20210115192810412](http://cdn.noteblogs.cn/image-20210115192810412.png)

BIO适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，有并发局限，是jdk1.4之前的唯一选择

### 2.2 NIO

同步非阻塞，服务器实现模式为一个线程处理多个请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理

![image-20210115193804114](http://cdn.noteblogs.cn/image-20210115193804114.png)

NIO方式适用于连接数目比较多且比较短的架构，比如聊天服务器、弹幕系统、服务器间通讯等，编程比较复杂，从jdk1.4开始支持

### 2.3 AIO

异步非阻塞，AIO 引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用

