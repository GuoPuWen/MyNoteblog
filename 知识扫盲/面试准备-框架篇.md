# 3. Spring IOC方面

## 3.1 IOC原理

Spring的IOC容器是一种控制反转的思想，使用了依赖倒置的原则，例如我原本的A依赖于B，B依赖于C，C依赖于D，也就是有一个层级关系，如果现在有一个需求，将最下层的代码进行变动，那么一整个依赖关系都需要重新改动，而Spring的IOC是一种依赖倒置，将这种依赖关系倒置过来，这样即使下层代码出现变动，也不需要改变上层代码，因为是靠注入的方式实现的。

Spring的IOC管理了整个web应用的组件生命周期、组件之间的依赖关系，使得开发人员只需要关注具体的开发，Spring的IOC本质上就是一个map，里面存储了各种对象

## 3.2 IOC容器初始化步骤

总体步骤是，BeanFactory加载配置文件，将一个一个组件加载成BeanDefintion，然后在将BeanDefiniton注册到容器中。然后在初始化的过程中，伴随着对象的生命周期有一系列的组件穿插在各个部分，比如如果对象xxxAware接口，就调用相应的方法，接着加载BeanPostProcess对象，执行里面的默认方法，如果bean实现了InitalizingBean方法，也会执行里面的默认方法，同时如果对象还还指定了init-method方法，也会执行里面的方法，当一个对象被初始化完成之后放入到ConcurrentHashMap中，在使用完成之后，以相同的顺序分别执行对应的方法，比如BeanPostProcess对象里面的afterInitalizingBean方法，DisposableBean接口里面的方法，接着执行destory-method里面的方法。

## 3.3 bean的作用域

- singleton：单例的
- prototype：每次使用都会创建一个新的对象
- request：在一次的http请求上都会产生一个bean
- session：作用域在一个session会话
- global-session：全局session会话

# 4. Spring AOP方面

## 4.1 思想

Spring的AOP是指面向切面编程，如果说面向对象编程是一条从上到下执行的流失线的话，面向切面编程就是在这条流水线上设置一个切面，这样的好处是我觉得是将一些通用的代码给抽取出来，减少代码模块之间的冗余，比如说我在项目中使用到的是利用AOP做一个日志处理，如果说使用面向对象编程的话，我需要在每一个Controller上去写我这个日志的逻辑，那么如果日志逻辑代码一旦变动将需要修改整个项目的Controller，而AOP编程便将这些日志的代码抽取出来，只是在当我们的程序运行到了指定切面出的时候，才执行对应的方法，这就减少了代码之间的依赖关系，利于扩展

## 4.2 原理

Spring的AOP是基于动态代理的，而动态代理的方式一般有两种，一种是jdk自带的，还有一种是使用Cglib，那么在Spring中如果一个对象实现了某个接口，就会使用jdk自带的，如果没有实现就使用Cglib生成一个代理对象，因为jdk再带的动态代理的限制是一定要有一个接口的

- jdk动态代理原理是：基于反射的，通过实现的InvocationHandler接口调用处理器，然后通过反射机制获取动态代理类的构造函数，然后通过构造函数创建动态代理类的实例，然后作为参数传入

- CGLib：将代理对象的class文件加载进来，通过修改字节码生成子类来处理

## 4.3 使用

使用Srping的AOP可以使用注解和xml文件的方式，我在项目中用到的是注解的方式，需要先在配置文件中开启对注解aop的支持，然后在配置一些通知方法，例如前置通知、后置通知、异常通知、返回通知和环绕通知，只需要在这个通知方法上配置切面即可

# 5. Spring启动原理

首先就是web应用启动时，因为在web.xml中配置了一个监听器，提供了一个ServletContext上下文环境，其实Spring的启动过程就是IOC容器的启动过程，BeanFactory加载配置文件-->组装成BeanDefintion-->将BeanDefintion加入到ConcurrentHashMap容器中

# 6.Tomcat启动流程

Tomcat需要做的有两件事情：①处理Socket连接，负责网络字节流Request和Response之间的转换 ② 加载和管理Servlet，以及处理具体的Request请求，也分别对应着两个组件连接器(Coyote)和容器Catalina。当我们调用tomcat的启动脚本的时候，会调用Bootstrap的main方法，而Bootstrap的main方法里面包含了init方法用来创建Catalina和初始化类加载器，也在main中调用load方法进行加载一些相关的组件(比如用于加载xml的组件)，然后tomcat开始监听Socket连接，处理Socket连接

# 7.Nginx负载均衡算法

- 轮询：是默认的算法，依次将请求分配到后台服务器中
- 权重：可以在Nginx的配置文件中配置一个权重，指定轮询的的几率
- ip的哈希：通过请求者的ip的hash值散列到后台服务器上，可以同一个ip
- 根据响应时间：响应时间段

# 8. Redis方面

## 8.1 缓存处理流程

用户--> 判断缓存是否存在对应的数据 -->如果缓存中存在对应的数据那么直接返回 -->如果不存在则从数据库中查询 --> 如果没有则返回空数据

使用Redis能够保证高性能与高并发，高性能是指用户下一次获取数据可以直接从缓存中获取，而缓存是存在内存里面的，不需要经过磁盘的时间所以性能比较高，高并发是指在使用了Redis后 服务器能承担的QPS更多，大概从1w到10w

## 8.2 Redis常用数据结构

- string：简单的key、value类型
- list：双向链表类型，可以反向查找与遍历
- hash：类似于HashMap，用于存储对象很方便
- set：无序集合、不出现重复数据，使用的Redis可以很好的做交集、并集、差集等操作
- sorted set：相比set增加一个权重参数，可以通过这个权重进行排序，相当于HashMap和TreeMap的变形体

## 8.3 Redis单线程？

Redis在4.0的时候其实已经引入了多线程，但是总体上来说还是单线程的，Redis使用多路复用技术来监听大量的socket请求，IO多路复用技术让Redis不需要额外创建多余的线程来监听客户端的大量请求，降低资源的消耗，而在Redis4.0的时候引入多线程只是在一些操作大对象的数据的时候使用的，所以不会有线程安全问题，我觉得Redis是单线程的是基于以下的考虑：

- 单线程利于维护，不会出现线程安全问题
- Redis的性能瓶颈并不是CPU，而是网络IO和内存
- 使用多线程可能会出现死锁、线程上下文切换等等，反而会降低性能

在Redis6.0的时候再次引入了多线程，但是多线程只是作用在网络读写这种比较耗时的操作上，执行命令仍然是单线程的所以不会有线程安全问题

## 8.4 数据过期的删除策略

Redis维护了一个过期字典，其实就是一个map，用来保证Redis的数据过期策略，key指向属性的某个值，而value是一个时间戳，维护这个时间用来判断数据是否过期

数据过期的删除策略有两种：

- 惰性删除：只有在取出key的时候才会进行删除，这样对CPU友好但是对内存不同友好
- 定期删除：每隔一段时间就定期的删除过期的数据

## 8.5 内存淘汰机制

可以从以设置过期时间的数据中删除和在全部时间中删除

- volatile-lru：从已设置过期时间的数据集中挑选最近使用最少的数据
- volatile-ttl：从已设置过期时间的数据集中挑选快要过期的数据
- volatile-random：从已设置过期时间的数据集中随机挑选
- alikeys-lru：从存储空间的数据集中挑选最近使用最少的
- alikeys-random：从存储空间的数据集中随机挑选数据进行淘汰

## 8.6 持久化机制

Redis需要持久化可以保证在Redis挂掉之后进行重启可以恢复之前的数据。Redis有两种持久化方式：①快照RDB ② 只追加文件 AOF

- 快照RDB：创建快照来获取存储在内存中的数据某个时间点上的副本，创建快照之后可以对快照进行备份，这样就可以在其他机器上运行。快照RDB的方式有两种SAVA 、BGSAVA，使用SAVA会使用Redis进程来进行持久化一般不使用，而BGSAVA将会fork一个子进程来进行RDB的持久化。
  - RDB的优点是：内容为二进制形式，占用内存小，对容灾非常有帮助，可以传输到远程Redis服务器上进行恢复数据
  - RDB的缺点是：只能保存某个时间段的数据，如果在一个时间间隔内Redis服务器挂掉了，那么期间的数据无法保存。在数据集比较大的情况下，因为做持久化需要fork出一个子进程，fork出的子进程过多将会很耗时
- AOF持久化：Redis默认是RDB的持久化方式，使用AOF在每次执行一次Redis命令，Redis就会将这个命令写入到AOF文件中
  - AOF的优点：保存的数据更加完整，Redis有三种保存策略：每次操作保存、每分钟保存、跟随系统的持久化策略，也就是说如果Redis发生宕机，最多丢失1秒钟的数据。AOF持久化文件非常的好解析，因为里面存的直接就是命令
  - 对比AOF，RDB存储相同的数据资源消耗更大

## 8.7 缓存穿透

缓存穿透是指大量请求的key根本不在缓存中，导致请求直接落在了数据库上，根本没有经过缓存这一层。

解决办法：

- 做好参数校验，一些不合法的参数应该直接返回给客户端
- 设置缓存无效key，如果缓存和数据库都查不到该key对应的数据，就将该key设置到Redis中并设置一个过期时间，这种方法适用于key变化不频繁的情况(key：表名:列名:主键名:主键值)
- 使用布隆过滤器：布隆过滤器可以非常方便的判断某个数据是否存在与海量数据中的，缓存穿透的问题就是key不合法，那么可以在进行查询之前使用布隆过滤器判断key是否存在

## 8.8 缓存击穿

击穿，一击致命，表示和缓存穿透不一样的是缓存中的一个热点数据，在大量的请求下突然失效了，就造成这些请求全部都要落在数据库上，给数据库造成了巨大的压力

解决方案是加锁让大量请求进行排队(不建议)、设置热点数据的缓存永远不过期

## 8.9 缓存雪崩

缓存雪崩是指缓存在同一时间内大面积失效，导致后面的请求都落在了数据库上，造成数据库在短时间内承受大量的请求

可以使用设置不同的缓存时间，或者设置缓存永久不失效

## 8.10 缓存预热

缓存预热是一种优化型的方案，缓存预热是指在Redis启动的时候，实现就把查询结果保存在缓存中，让用户在第一次查询的时候就可以直接从缓存里面拿数据，这样就可以提供用户的体验

实现思路：

- 把缓存的方法写在系统的初始化方法上，让系统一启动就加载这些数据
- 设置定时任务，到时候自动进行缓存预热

## 8.11 Redis的集群方式

### 主从复制

主从复制，主从复制是指Redis中有一个主节点，然后主节点可以拥有多个从节点，一个从节点可以使其他服务器的“主节点”

主从同步的优点是：

- 提高Redis的服务性能，可以做到分摊压力，读写分离，可以使用主服务器进行写操作，而把查询任务交给从服务器，这样极大的提高了服务器的性能
- 防止数据丢失，当主服务器的磁盘坏掉之后，其他服务器依旧保留着相关的数据

缺点：

- 一个致命的缺点是，当主服务器突然宕机了，需要进行人为的干预才能恢复Redis的使用

#### 哨兵模式

为了解决主从同步的缺点，可以增加一个哨兵时刻监控主服务器的状态，一旦发现有问题之后，立即将从服务器提升为主服务器

哨兵的工作原理：

- 每个哨兵进程都会以一定的频率发送向这个集群中的所有主服务器和从服务器以及其他哨兵进程发送一个ping命令包
- 如果一个主服务器在最后一个发送ping命令之后30秒后，哨兵进程还没有收到确认，则该主服务器被标记为主观下线
- 如果一个主服务器被标记为主观下线，那么所有正在监视这个主服务器的哨兵都会以每秒一次的频率发送一个ping包
- 如果有足够的数量的哨兵确认该主服务器进行主观下线的状态，则该主服务器会被标记为客观下线
- 一旦主服务器被标记为客观下线，那么所有的哨兵会重新按照规选出一个新的主服务器

哨兵模式的优点是解决了在主存模式下的需要人为干预才能选出主节点的缺点，但是缺点是增加哨兵进程，需要进行额外的开销，效率不是很高

### 集群服务

集群服务是Redis真正多机运行的方案，往完全抛弃了主从同步和哨兵模式，是真正的多主多从。主要的工作方式是在每个Redis的节点上，都有两个东西一个是插槽，还有一个就是cluster，就是集群管理的插件，当我们存取的key到达的时候，首先会通过一个哈希算法算出一个哈希槽，然后通过这个值找到插槽对应的节点，然后将直接自动跳转到这个节点上进行存取

## 8.12 Redis的基本数据及其底层原理

- string：字符串类型，在Redis中使用的是SDS，就是Redis自己底层封装的里面有三个字段：length长度、free剩余空间、char数组，好处是1.保存了字符串的长度，然后常数级别的返回字符串长度，因为有free字段在修改SDS的时候会先检查空间分配
- list：使用双向链表
- hash：字典
- set：
- zset：使用跳表实现

## 8.13 Redis主从复制

Redis主从复制主要有以下几点好处：

- 读写分离，可以让主节点负责写、从节点负责读，提升性能
- 数据冗余：主从复制实现了数据的热备份，提供了AOF和RDB以外的另外一种方式
- 故障恢复：当主节点挂掉之后，从节点可以提供服务，实现快速的故障恢复
- 负载均衡以及高可用

Redis的主从复制大致分为三个阶段：

- 连接建立阶段：主要作用是在主从之间建立连接，为数据同步做好准备
- 数据同步阶段；主从节点之间的连接建立好了之后，便可以开始数据同步，就是使用psync命令，进行从数据的初始化
- 命令传播阶段：主节点将自己执行的写命令发送给从节点，让从节点接收命令并且执行，从而保证数据的一致性

# 9.SpringMVC的工作原理？

1. 请求发送到前端控制器中(DispatchServlet)中，前端控制器是请求流程的主管，负责各个组件之间的通信
2. 前端控制器将请求交给处理器映射器，处理器映射器返回对应的处理器
3. 接着请求交给处理器适配器，由处理器适配器找到真正的处理器Handle
4. 处理器处理请求，返回一个ModelAndView
5. 视图解析器解析ModelAndView得到视图
6. 最后将视图进行渲染，得到真正的页面，最后有前端控制器返回给客户端

其中涉及到了很多组件：前端控制器、处理器映射器、处理器适配器、处理器、视图解析器、视图渲染器

# 10.Mybatis方面

## 10.1 ${} 和 #{}

- ${} ：是properties中的变量占位符，可以用于标签属性和sql内部，是静态文本替换
- /#{}：是sql中的参数定位符，mybatis会将`#{}`替换为？，并且在预编译对象的时候将？占位符替换为相应的值

## 10.2 为什么要一个xml配置文件对应一个接口

使用dao接口，也就是mapper接口，将接口的全限定类名写在xml配置文件的namespace位置，而接口的方法名写在id上，用于确定一条sql语句对应的方法，因为mybatis是使用JDK的动态代理实现的，必须要有一个接口，并且这个接口是不能重载的，因为是使用全限定类名和方法名来进行查找的

## 10.3 Executor

Mybatis执行二级缓存的Executor有：CacheingExecutor

Mybatis执行一级缓存的Executor是BaseExecutor，其中有三个实现类：

- SimpleExecutor：简单执行器，每次只需要一个update和select就开启一个statement对象，用完立刻关闭
- ReuseExecutor：可重用执行器，可以重复利用JDBC的statement，减少预编译的次数，遇到相同的sql可以直接使用
- BatchExecutor：批处理执行器，每次的操作不会立即执行，当调用flush的时候会一次性提交到数据库，适用于批量插入的场景

## 12. Spring的声明式事务相关

首先事务相关的四个特性：

- 原子性：事务是一个原子操作，一系列的操作要么一起完成要么一起失败
- 持久性：指的是无论发生什么系统错误，数据的结果应该是一直存在的
- 一致性：指的是在事务执行完成之前与执行完成之后，数据的状态应该是一致的
- 隔离性：指的是多个事务之间，应该是互不影响的

Spring提供了两种事务机制，编程式事务和声明式事务，编程式事务是一种侵入型的事务管理，需要手动的开启事务和提交事务回滚等。而Spring更提倡的是声明式事务，声明式事务是建立在AOP的基础上，对标注了声明式事务注解的方法进行拦截，在目标方法开始之前加入一个事务，然后在目标方法结束之后根据情况提交还是回滚

Spring的传播机制，事务的传播性一般用在事务嵌套的场景，比如是一个事务方法里面嵌套了另外一个事务方法，事务应该怎么处理的问题

- requird：是Spring的默认传播机制，满足绝大部分业务需求，如果外层有事务，则把当前事务加入到外层事务，一起提交，然后一起回滚，如果外层没有事务，就新建一个事务执行
- reques_new：每次开启一个新事务，同时把外层事务挂起，当前事务执行完毕，然后恢复外层事务即可，如果外层没有事务则创建一个事务
- support：外层有事务就加入外层事务，如果外层没有事务，如果外层没有事务，就使用非事务的方式进行执行
- naver：不支持外层事务，如果外层有事务就抛出异常
- nested：可以保存一个状态保存点，从而避免嵌套事务进行回滚，即可以各回滚各的

# 13.BeanFactory与FactoryBean

BeanFactory是一个Factory，是一个IOC容器，是Spring中的最上层的接口，BeanFactory定义了IOC容器的最基本的形式，并且提供了IOC容器的最基本的方法例如getBean等等，在Spring中给出了很多具体的实现例如ApplicationContext，XmlBeanFactory

FactoryBean是一个容器中的bean，但是这个bean不是一个简单的bean而是一个可以生产其他对象的工厂bean，作用是当在实例化bean比较复杂时，可以将这个bena实现这个FactoryBean来定制化生成bean，该接口具有三个方法getObject、getObjectType、isSingleton

# 14.在spring框架中用到的设计模式

- 工厂模式，实现FactoryBean接口的实例，当调用getBean()的时候会自动调用该bean的getObject()方法，所以返回的不是FactoryBean对象而是实现了FactoryBean接口的实例
- 单例模式：ioc容器默认的实例时单例的，可以指定@scope注解来指定实例时单例还是多例的，当时多例的时候时懒加载的，并且Spring实现单例是使用DCL双重校验锁的
- 适配器模式：在SpringMVC解析流程中，前端控制器将请求交给处理器映射器，接着交给处理器适配器得到真正的handle，这里使用的就是适配器模式
- 代理模式：Spring中的AOP切面编程便是使用了代理模式，如果实现了接口就使用jdk自带的动态代理，如果没有实现接口，则使用cglib操作字节码生成代理对象
- 模版方法模式：父类定义骨架，交由子类具体实现，具体的例子有JDBCTemplate

# 15.SpringBoot的好处

- 基于Spring，Spring的好处都具备IOC、AOP、声明式事务等等
- 简化依赖：spring-boot-xxx-xxxjar依赖包含了很多相关的依赖
- 简化配置：可以自动装配。有xxxautoconfig类做到自动配置
- 简化部署：可以直接打成jar包，里面嵌套了Tomcat

# 16.SpringBoot自动装配原理

首先，SpringBoot的一个应用一般都会有一个main方法，在main方法上标注一个@SpringBootApplication注解，其实这个注解就是由一堆注解组成的，关于自动配置的注解主要是@EnableAutoConfiguration，这个注解会使用到Spring底层导入组件的注解@Import，里面会一个自动配置的选择器，这个选择器就会给容器导入自动配置类，当应用启动的时候，会自动的从类包下的META-INF/spring.factories中获取EnableAutoConfiguration的值，然后将这些配置类导入对应的容器中，就进行了自动配置的工作



# 17.Spring解决循环依赖问题

假如创建实例的时候A依赖于B，B依赖于A，那么在调用getBean方法获取A的实例的时候，会执行doGetBean、查询缓存、创建实例，将实例完成后的A放入三级缓存中，接着调用装配属性的方法发现依赖B，那么接着创建B，同样的执行doGetBean、查询缓存、创建实例完成时候放入三级缓存中，接着调用装配属性的方法发现依赖A，接着调用doGetBean方法在三级缓存中查到了A的实例，那么直接返回A，并将A放入二级缓存中，不在执行创建的流程，那么B就算装配好了，将B放入一级缓存中，B创建完成之后自然A就装配好了



# 18.Mybatis二级缓存如何实现的

首先Mybatis的运行分为两部分，一是加载配置文件，二是SqlSeesion执行流程，而SqlSession只是提供了一个门面就是只提供了Api，真正去执行的是Executor，当开启了二级缓存的时候，首先会执行二级缓存的流程就是CacheExecutor，而CachExecutor中又实用装饰器模式装饰了一级缓存相关，如果二级缓存没有命中，那么调用一级缓存BaseExecutor，执行里面的query方法这是一级缓存，如果还没有命中那么再使用真正的执行器例如SimpleExecutor、ReuseExecutor、BatchExecutor执行里面的doQuery方法查询数据库然后返回数据

# 19.Spring常用注解

组件类注解：@Bean  @Component  @Controller  @Service 

装配类注解：@Autowried @Resource jdk的注解 @Qualifier

配置类注解：@Configuration

SpringMVC处理请求类注解：@RestCpontroller @RequestMapping @RequestParam @PathVariable

事务型注解：@Transactional

AOP相关：@Aspect @Before @Around 等等



# 20.消息队列的好处

- 解耦：例如订单系统需要调用库存系统，传统的做法是订单系统直接调用库存系统，如果库存系统调用失败，因为具备分布式事务所以整个操作都失败，而引入消息队列之后，用户下单，订单系统将数据写入消息队列，则返回成功，库存系统订阅下单的消息，采用推/拉的方式获取下单信息，进行库存擦欧总
- 异步：比如一个场景，用户注册之后需要发送注册邮件和注册短信，传统的做法是发送注册邮件->然后发送注册短信，也可以并行的处理，例如将用户注册的信息写入数据库，这样在发送注册邮件的同时发送注册短信的信息。而使用了消息队列之后，就变成注册用户将注册信息写入数据库然后写入消息队列，发送注册服务和发送邮件服务区异步的拉取消息队列里面的内容
- 削峰：对于短时间内用户请求过多，可以先将用户的消息写入消息队列，如果消息队列写满了，再抛弃用户请求或者跳转到错误界面

# 21.怎么做熔断？

在分布式系统中，如果下游的服务因为访问压力过大响应变慢或者失败，这个时候上游服务可以做让熔断处理。可以暂时切断对下游服务的调用，做熔断的步骤有：

- 定义一个识别是否处于”不可用“状态的策略，例如可以如果在10秒内出现100次无法连接这个情况，那么就可以判定下游服务不可用了
- 切断联系：当判断了下游服务不可用的时候，要果断的把调用服务之间的调用切掉，可以在上游代理进程发出请求的时候直接返回错误
- 定义一个识别是否处于可用的状态：切断联系之后，需要尽快的恢复下游服务的功能，这个时候就需要每隔一段时间在用这个识别不可用的反向指标判定即可
- 重新恢复正常

# 22.怎么做限流

首先是要获取系统能力的上限，可以使用压测根据Jmater获取这个系统能处理多少的并发数，然后制定干预流量的策略，一般来说有四种方式：

- 固定窗口：在一个固定的周期内，统计这个周期内的请求然后设置一个阈值-计数器，当超过这个阈值的时候就会触发流量干预，直到下一个周期计数器清零。这种方式的缺陷是因为进入的请求数量更时间不是正比的关系，这样就导致某个时间内进去的请求多都干预了，没有将资源得到充分利用
- 滑动窗口：就是在固定窗口的基础上将周期进一步的细分，这两种方式无论怎么细分还是没有办法做到资源的充分利用
- 漏桶：不管进来的请求有多少，出去的速率是一定的，如果进来的请求桶装不下了，那么就进行流量干预，其实就是一个缓冲区，通过这个缓冲区将不平滑的流量整成平滑的，有点像将交流电整成直流电的意思
- 令牌桶：漏洞的一个缺点是这个桶是固定的，但是在系统运行的过程中，可能会受到其他进程的影响所以这个缓冲区的大小是不确定的嘛，而令牌桶便是在一个桶里面放令牌会有一个进程区不断的生成令牌，当一个请求过来的时候要先判断是否拿到令牌，拿到了令牌则处理请求，没有则进行流量干预

# 23.什么是CDN

CDN系统能够实时的根据网络流量和节点的连接、负载、拥堵情况和响应时间等信息将用户的请求重新导向到离用户最近的恶服务节点

# 24.怎么做削峰

在业务高峰期，如果请求的浏览峰值过大，那么就要做削峰好处是可以让服务器平稳的运行，还能节省服务器的资源成本，在秒杀的场景下做削峰是很有必要的：

- 排队，使用消息队列。当大量的请求过来的时候使用消息队列缓冲瞬间的流量，在推送的一端平稳的将消息推送过去
- 答题或者验证：在秒杀的时候可以在购买前增加一个答题验证的步骤，使用这个时间可以延缓请求嘛，达到削峰的作用，还有就是能够防止作弊等等
- 分层过滤：比如请求要经过CDN-前台系统-后台写系统-DB，经过一层层的过滤将一些无效的请求给过滤掉，就像一个漏斗一样
