# 1.什么是操作系统

操作系统是管理计算机硬件和软件资源的一种程序，我理解的操作系统是为我们使用者提供了一种抽象或者是说接口，因为我们不可能去操作硬件，而操作系统给我们屏蔽了这些细节，提供了进程管理、内存管理、文件系统、网络IO、设备管理等一些列的功能



# 2.计算机的硬件

冯 诺依曼体系结构：运算器、存储器、控制器、输入、输出设备

### CPU

CPU是计算机的大脑，循环往复的从内存中取出指令、解码并且执行。并且由于CPU取指令的速度比执行指令的速度更慢所以存在寄存器用于提高速度，同时还需要程序计数器用于保存下一条指令的地址。





### 存储器

存储器的设计目标是容量大、速度快、而且便宜，但是目前单一的存储器无法满足这些要求，所以存储器一般都具备缓存、主存、辅存三层结构用来达到容量大、速度快、便宜的这些指标

存储器的分类主存分为随机存储器(RAM) [静态RAM、动态RAM]、只读存储器(ROM) [MROM、PROM、EPROM、EEPROM]，辅存可以有磁盘、SSD固定硬盘等等



### 输入输出

输入输出设备是用户与计算机之间进行通信的终端设备，也就是IO设备，IO设备与主机之间交换信息的时候，一版有以下几种方式：

- 程序查询方式：CPU 通过程序不断的查询iO设备是否已经做好准备，使用这种方式CPU要不断的查询，并且读取的时候也要一字一字的读出，所以效率很低
- 程序中断方式：CPU在启动IO设备的时候，不查询设备是否已经准备好，而是继续执行自身的程序，只是当IO设备准备就绪的时候给CPU发出一个中断，这个时候CPU才进行响应，大大提高了效率
- DMA直接存取的方式：程序中断方式是当程序发出中断响应之后，CPU必须停止现在的程序而去执行中断程序，而DMA方式能CPU直接和主存交换信息，又是提升了效率

# 3.进程状态与模型

进程一般具备三种状态：

- 运行态：该时刻进程占用CPU
- 就绪态：可运行，但是因为没有得到CPU的调度
- 堵塞态：因为某种事件发生，比如需要等待输入等等使得进程不能运行

进程模型，操作系统维护一张表格，相当于一个结构数组，就是进程表，而每一个进程都占用一个进程表项，该表项包含了进程状态的重要信息，例如程序计数器、内存分配情况、堆栈指针等等，维护这些表项，当发生进程进入堵塞态之后重新获得CPU之后能快速启动

# 4.为什么需要线程？

线程是一种迷你进程，比如打开一个word文档此时有一个进程，在这个进程里面有很多线程比如一些检查拼音，字数统计等等，而需要线程的原因有以下方面：

- 能够分解进程，比如上面举的例子
- 创建更快，线程比进程更加轻量所以创建和销毁都要更快
- 使用多线程性能更好，如果线程都是存在大量的IO处理，如果将线程换成进程则速度更慢

# 5.临界区

临界区是指多个进程对共享变量访问的程序片段，应任何两个进程不能同时处于临界区，临界区外运行的进程不得堵塞其他进程同时不能使进程无限期等待进入临界区

# 6.CPU进程调度算法

评判调度算法的指标是：`吞吐量`：系统每小时完成的作业数量；`周转时间`：从一个批处理作业提交直到该作业完成的平均时间；`CPU利用率：`每小时完成多少作业

- `先来先服务`：CPU按照进程请求调度的顺序使用CPU，优点是算法简单，易于理解，缺点是不利于短作业，比如有一个需要大量IO时间的IO密集型进程存在，则会使CPU利用率下降

- `短作业优先`：从就绪队列中选取最短的进程分配资源，可以获得比较少的周转时间，但是对于长作业不利，同时也没有考虑作业紧迫性
- `轮转调度`：每个进程被分配一个时间片，允许该进程在该时间段内运行，当时间片用完之后需要进程上下文切换，这需要消耗资源，要进行恢复现场，所以对时间片的把控就非常重要
- `优先级调度`：每个进程被赋予一个优先级，允许优先级高的进程先允许
- `多级反馈队列算法`：前面先来先服务对短作业不利，而短作业优先对长作业不利，而多级反馈队列算法则综合了以上的优点，多级反馈队列优先算法需要设置多个就绪队列，并为每个就绪队列设置一个优先级，优先级高的队列的时间片少，当一个新进程进入内存时首先放入第一队列的末尾，只有当第一队列空闲时调度程序才将调度第二队列中的进程运行

# 7.死锁

死锁是指两个进程在执行的过程中互相争夺对方手里的资源，例如进程一持有A锁想获取B锁，而进程二持有B锁想获取A锁就造成了这种僵局，如果没有在外力的作用下进程将无法在运行下去

产生死锁的原因是1⃣️竞争资源；2⃣️进程间执行的顺序非法

产生死锁的必要条件：

1. 互斥条件：一个资源只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而堵塞的时候，对已经持有的资源不释放
3. 不剥夺条件：进程已获得的资源，在未使用之前不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

Java中出现死锁怎么检测：Jps 查看当前运行的进程ID，然后Jstack分析该进程ID，在Java8环境下能直接报出死锁错误，并且给出两个线程互相持有的资源

# 8.内存管理-地址抽象

在早起的计算机操作系统是直接访问物理内存的，直接使用物理内存具有以下几个原因：

- 对操作系统不安全，因为用户可以直接操作物理内存，那么用户就可以操作系统那段内存空间
- 无法同时运行多个程序，因为每一个程序对应一块真正的物理空间

而地址抽象是指程序拿到的都是逻辑地址，要通过地址变换机构变为物理地址

# 9.内存管理-分配内存-连续分配

连续分配的方式是指为一个用户程序分配一个连续的内存空间，连续分配有单一连续分配、固定分区分配和动态分区分配：

- 单一连续分配：将系统内存分为两部分，一部分用于系统，一部分用于用户，一般用于单任务，单用户
- 固定分区分配：将内存分为若干固定大小的区域，如果程序需要内存则分配一块空间，使用这种方式容易产生内存碎片，因为控制不了程序需要的大小
- 动态分区分配：是指根据进程的需要，动态的给他分配内存，这是指将一个进程的所有代码进行分配，所以还是连续的进行的分配，后面所讲的页段式存储都是将进程中的代码分为段页进行分配，所以是不连续的，每个段页在内存中是不连续的。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

要完成动态分区分配需要记录空闲分区和已分配分区，一般需要空闲分区表和空闲分区链这两种数据结构，动态分区分配的算法有：

- 首次适应算法：FF 算法要求空闲分区链以地址递增的次序连接，在分配内存的时候，从链首开始寻找，直到找到一个大小能满足空闲分区为止。优点是优先利用了内存中的低址部分，缺点是容易产生内存碎片
- 循环首次适应：再FF的基础上，不是每次从首部开始查找，而是从上次找到的空闲分区开始查找。有点是使得空闲分区分布均匀，但是会缺乏大的空闲分区
- 最佳适应算法：再分配内存的时候，总是把能满足要求又是最小的空闲分区找出来进行分配内存
- 最坏适应算法：总是挑选最大的空闲区用来分配内存

# 9.内存管理-分配内存-页段式存储

使用连续分配的方式，容易产生很多的碎片，所以就产生了页段式存储：

- 分页式存储：把用户程序的地址空间分为大小相等且固定的一页一页的形式，然后将内存空间页分为若干个物理块，通过页表将程序的页面号对应到真正的物理地址
- 分段式存储：将用户程序根据代码的内容分为一个一个段，然后通过地址映射机构将虚拟地址转为物理地址
- 段页式存储：集中了页式存储和段式存储的优点，先将程序分为段，然后在将每一段分为一页一页，这样就更加提高了内存的利用率

区别：分页存储页的大小固定且且由系统决定，分页式系统的行为而分段则是由用户所编写的程序来进行分段的

# 9.内存管理-快表与多级页表

在分配内存的时候，有重要的两点：

- 从虚拟地址到物理地址的变换要快
- 页表占用的空间不能过大

为了解决上面两个问题，分别出现了快表和页表：

### 快表

因为页表是存在内存里面的，所以CPU在存取数据的时候需要经过两次内存：

- 从内存中的页表取出对应的数据，同时通过地址变换机构算出真正的物理地址
- 通过物理地址再次从内存中存取数据

这就导致CPU的处理速度降低了1/2，为了提升地址变换速度，提出了快表，在CPU的内部高速缓冲寄存器里面设置一个快表项，其内容和页表中的是一样的，所以CPU存取数据的步骤为：

1. 首先从CPU内部的高速缓存区里面查找，如果命中，则直接从内存中取值，一次读取内存
2. 如果没有命中，则从内存中的页表查找拿到物理地址，然后再从内存中通取值，同时还需要将数据写入到CPU的高速缓存里面

### 多级页表

多级页表就是防止全部页表项放在同一张页表上导致页表占用的内存过高的问题，多级页表是典型的空间换时间

# 10.虚拟内存-局部性原理

程序局部性原理是指：在程序执行时出现局部性的规律，局部性一般有两种形式，空间局部性和时间局部性：

- 时间局部性：被使用过的存储器位置在未来会被多次引用
- 空间局部性：一个存储器的位置被引用，那么他附近的位置也会被引用

正是因为局部性原理，才可以知道在程序运行的时候，没必要将所有的页面装入内存，只需要将部分需要的装入内存，在后续需要使用的时候再经过一些置换算法将不需要的页面置换出去，换进来需要的页面

# 10.虚拟内存-页面置换算法

因为虚拟内存技术只是将部分当前需要的页调入内存中，但是如果在程序运行期间，所要访问的页面不在内存中，但是内存已无可用的空间的时候，就需要将需要的页面调入，不需要的页面调出，于是就有了下面的页面置换算法

- `最佳置换算法`：首先这是一个理想的算法，最佳置换算法淘汰的是后面永远不使用或者在最长时间内不再访问的页面，但是CPU是无法预测那个页面是未来最长时间不使用的，所以这个算法只是一个理想算法
- `先进先出算法`：这是一个简单的算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰
- `最近最久未使用算法(LRU)`：最佳置换算法是判断最近的未来，而最近最久未使用算法是判断最近的过去，LRU算法要为每一个页面记录自上次被访问以来所经历的时间T，当需要淘汰页面时，选择淘汰T值最大的

# 11.CPU寻址方式

指令：操作码 操作数

8088/8086CPU一共有七种寻址方式：

- `立即寻址`：操作数在内存中的地址直接存放在指令中，紧跟操作码之后，作为指令的一部分存放在代码中，例如MOV AL,66H
- `直接寻址`：操作数在内存中的地址由操作数地址的16位偏移量加上段基址mov ax,[4000h]
- `寄存器寻址`：操作数在内存中的地址是寄存器中的内容，需要从寄存器中取操作数 mov ax, bx
- `寄存器间接寻址`：操作数在内存中的地址是寄存器的偏移地址加上基址组成mov ax, [bx] 
- `寄存器相对寻址`：操作数在内存中的地址由寄存器的内容加上给出的一个偏移量组成
- `基址-变址寻址`：操作数在内存中的地址是由一个基址寄存器的内容和一个变址寄存器的内容和基址

# 12.系统调用

 操作系统一般分为两个运行状态，内核态和用户态，在内核态下CPU可以执行任何指令，在用户态下CPU只能执行非特权指令。而系统调用计算用户在用户态下申请调用内核态，使得进程可以访问内核