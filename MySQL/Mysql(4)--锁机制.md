前面聊到事务的四大特性：原子性、一致性、隔离性、持久性，而要解决隔离性问题，Mysql有两种解决方案：①利用锁 ②MVCC多版本并发控制。而今天就来聊一聊Mysql锁的机制

# 一、锁的类型

Mysql中常用的两种存储引擎：Innode和Myisam引擎，而Myisam引擎采用的是表级锁，Innode采用的行级锁和表级锁，默认使用的是行级锁

- 表级锁：Mysql中`锁的粒度`最大，是对当前整张表进行加锁实现简单，资源消耗也小，加锁快，触发锁的冲突概论最大，但是并发度最低
- 行级锁：Mysql中`锁的粒度`最小，是对当前操作的行进行加锁，资源消耗大，加锁满，触发锁冲突的概率小，并发度高

对于行级锁来说，一般实现有以下几种算法：

- `Record Lock`：对索引项加锁，锁定符合条件的行，其他事务不能修改和删除加锁项
- `Gap Lock`：对索引项之间的"间隙"进行加锁，锁定记录的范围，不包含索引项本身。其他事务不能再锁范围内插入数据，就防止了别的事务新增幻影行
- `Next-key Lock`：锁定索引项本身和索引范围，即Record Lock和Gap Lock之间的结合

# 二、锁分类

表级锁和行级锁进一步划分又可以划分为共享锁(S)和排他锁(X)：

- 共享锁(S)：共享锁又可以被称为读锁，其他用户可以并发的读取数据，但是任何事务都不能获取到数据上的排他锁，直到释放了共享锁
- 排他锁(X)：排他锁又可以被称为写锁，如果事务T对数据对象A加上锁，则只允许事务T读取和修改A，其他事务都不能再对A加任何类型的锁，直到事务T释放A上的锁，它可以防止任何其他事务获取资源上的锁，一般用于更新操作

对于共享锁来说，如果一个事务已经获取到了某数据对象的共享锁，那么其他事务只能再对该数据对象添加共享锁，而不能加排他锁，获取共享锁的数据只能读数据，而不能修改数据

对于排他锁来说，如果一个事务已经获取到了某数据对象的排他锁，则其他事务不能再对A添加任何类型的锁，直到释放排他锁，获取排他锁的事务即可以读数据，又可以修改数据

我们知道，Mysql是允许事务同时存在多个锁的，为了支持在不同的粒度上加锁，Mysql还支持一种锁：意向锁。意向锁将锁定的对象分为多个层次，意向锁分为意向排他锁和意向共享锁。

当一个事务在给它需要的数据进行加锁的时候，如果遇到一个共享锁正在锁定自己需要的资源，自己可以再加入一个共享锁，不能加排他锁。但是如果一个事务在给它需要的数据进行加锁的时候，如果遇到一个排他锁锁定自己需要的资源，则就只能等待锁释放资源后自己才能获得锁定

而意向锁的作用就是：当一个事务在需要获取资源的时候，如果遇到自己的资源已经被排他锁占用的时候，该事务可以在需要锁定行的上面添加一个意向锁，意向锁分为意向共享锁(IS)，意向排他锁(IX)

- 意向共享锁：表示事务准备给数据行加入共享锁，事务在一个数据行加共享锁前必须获得该表的IS锁
- 意向排他锁：表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须获得该表的IX锁

==排他锁是一种表级锁，表示的仅仅是一种意向，IX和IX是表级锁，不会和行级的S,X发生冲突，只会和表级的S,X发生冲突==

四种锁之间的兼容性如下表

![preview](http://cdn.noteblogs.cn/v2-dcc66642a7aaeae13a0c582d17867e60_r.jpg)