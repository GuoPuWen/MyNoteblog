参考：《深入理解Java虚拟机第三版》

​			《宋红康JVM教程》

### 一、概述

上两篇介绍了类加载的过程中，Java虚拟机应该要做什么工作，当类加载进Java虚拟机的内存中的时候，Java虚拟机将这些内存空间划分了几个不同的区域，这个区域总体上称为运行时数据区，运行时数据区有五个不同的区域。这些区域有各自不同的功能，有不同的创建和销毁的时间，有的区域随着虚拟机进程的存在而存在，有的是依赖用户的线程的启动和结束而建立和销毁。下图则说明了Java虚拟机管理的内存分配情况：

![](http://cdn.noteblogs.cn/7.PNG)

通过上图，发现运行时数据区有：==方法区、堆、虚拟机栈、本地方法栈、程序计数器==，其中：

**线程独有的：** 虚拟机栈、本地方法栈、程序计数器

**线程共享的：**方法区、堆

>  注意：上图中各个区域的大小并不是按如图所示，事实上程序计数器是一块很小的区域

### 一、程序计数器

==程序计数器是一块很小的内存空间，是当前线程所执行的字节码的行号指示器，所以程序计数器是线程私有的==

程序计数器有以下特点：

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令
- 它是唯一一个在java虚拟机规范中没有规定任何OOM（OutOfMemoryError）情况的区域

在字节码文件中，程序计数器具体表现为之指令前的行号，例如：

```java
/**
 * @author 四五又十
 * @version 1.0
 * @date 2020/7/14 22:03
 */
public class PCRegister {
    public static void main(String[] args) {
        int i = 1;
        int j = 2;
        int num = i + j;
        System.out.println(num);
    }
}
```

如上程序，使用javap命令反编译一下：

![](http://cdn.noteblogs.cn/8.png)

这些就是指令地址（也叫偏移地址）

1. **使用PC寄存器存储字节码指令地址有什么用呢？/ 为什么使用PC寄存器记录当前线程的执行地址呢？** 

> 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
>  JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令

2. .**PC寄存器为什么会设定为线程私有**

> 我们都知道所谓的多线程在一个特定的时间段内指会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

