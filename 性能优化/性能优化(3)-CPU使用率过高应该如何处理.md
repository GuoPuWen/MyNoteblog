# CPU使用率如何计算的

CPU使用率是单位时间内CPU使用情况的统计，以百分比的方式展示，而其中有一个重要的点是单位时间，那么在CPU中时间是怎么计算的呢？

Linux是一个多任务操作系统，将每个CPU时间划分为很短的时间片，然后通过调度器分配给各个任务使用，因此造成多任务同时运行的错觉，为了维护CPU时间，Linux通过事先定义的节拍率(内核中表示为HZ)，触发时间中断，并且使用全局变量Jiffies记录开机以来的节拍数，每发生一次时间中断，Jiffies的值就加1。节拍率HZ是内核的可以配置的选项，可以设置为100、250、1000等，不同的系统有不同的数值，可以通过如下选项来查看配置值

```shell
gpw@gopuwe:~$ grep 'CONFIG_HZ=' /boot/config-$(uname -r)
CONFIG_HZ=250
```

而用户空间程序，内核还提供了一个用户空间节拍率USER_HZ，它总是固定值为100，也就是每秒触发100次时间中断，这样用户空间程序并不需要关注内核中HZ被设置为了多少，因为它总是固定值USER_HZ

Linux可以通过/proc虚拟文件系统获取到系统内部状态的一些信息，而/proc/stat提供的就是系统的CPU和任务统计信息，例如

```shell
gpw@gopuwe:~$ cat /proc/stat | grep ^cpu
cpu  2775 24 5952 24978 8647 0 136 0 0 0
cpu0 1521 13 2964 11313 5266 0 88 0 0 0
cpu1 1254 10 2988 13664 3381 0 48 0 0 0
```

通过man /proc可以查看到每一列所表示的具体含义

![image-20211201093651599](http://cdn.noteblogs.cn/image-20211201093651599.png)

第一列表示CPU的编号，没有编号表示所有CPU的累加，其他列表示不同场景下CPU的累加节拍数，单位是USER_HZ，也就是10ms(1/100)，其实就是不同场景下的CPU时间，然后其他列表示的是不同的各个场景

- user(us)，代表用户态CPU时间
- nice(ni)，代表低优先级用户态时间
- system(sys)，代表内核态CPU时间
- idle(id)，代表空闲时间，注意不包括等待IO时间
- iowait(wa)，表示等待IO的CPU时间
- irq(hi)，代表处理硬中断的CPU时间
- softirq(si)，代表处理软中断的CPU时间
- steal(st)，代表当系统运行在虚拟机的时候，被其他虚拟机占用的CPU时间
- guest(guest)，代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间
- guest_nice(gnice)，代表以低优先级运行虚拟机的时间

所以CPU的使用率，就是除空闲时间外的其他时间占总CPU时间的百分比：

```
CPU使用率 = 1 - (空闲时间) / 总CPU时间
```

那么我们根据/proc/stat中的数据可以轻而易举的计算出CPU的使用率，但是这个数据基本是无效的，因为/proc/stat中统计的是自开机以来的CPU时间，参考价值并不是很大。所以为了计算CPU使用率，一些性能工具例如top、ps一般都会间隔一段时间去计算这段时间内的平均CPU使用率。同样的在/proc/[pid]/stat中同样统计好了每个进程的运行情况的统计信息

上面介绍了一些CPU使用率的计算方法，但是我们并不需要自己去进行计算，因为各种各样的性能分析工具已经帮我们计算好了，但是需要注意的是每个工具所选取的时间间隔可能并不一样所以计算出来的CPU使用率也会有差距

# 查看CPU使用率

top和ps是最常用的性能分析工具：

- top显示了系统总体的CPU和内存使用情况，以及各个进程的资源使用情况
- ps则只显示了每个进程的资源使用情况

![image-20211201101126310](http://cdn.noteblogs.cn/image-20211201101126310.png)

上面截图是top显示后的数据，第三行便是显示的CPU使用率，具体每一列的数据在上面都有提到过，只不过这个时候的数据是使用率，top是默认3秒刷新一次，按下数字1可以切换到每个CPU的使用率，空白行后面是进程的实时信息，每一个进程都有一个%CPU列，表示进程的CPU使用率，它是用户态和内核态CPU使用率的总和，包括进程用户空间使用的CPU，通过系统调用执行的内核空间CPU，以及在就绪队列等待运行的CPU

top并没有细分进程的用户态CPU和内核态CPU，要想看到进程的详细情况，可以使用pidstat，这是一个专门分析每个进程CPU使用情况的工具，图中表示每隔1秒输出一组数据，共输出5组

![image-20211201102317176](http://cdn.noteblogs.cn/image-20211201102317176.png)

# CPU使用率过高怎么办

通过top、ps、pidstat可以很简单的分析出哪个CPU的使用率占用比较高，但是接下来应该怎么做呢？或许你会回答直接kill掉，这是不治本的因为当下次启动的时候，这个进程还是会占用比较高的CPU。当某个应用出现CPU使用率比较高的时候，我们应该很想知道是代码中的哪一个函数，找出这个函数我们可以进一步分析问题所在

一种比较常见的工具是perf top，类似于top，能够实时显示占用CPU时钟最多的函数或者指令，因此可以用来查找热点函数，例如执行

```shell
sudo pref top
```

注意在普通用户下，是不被允许访问内核的热点数据的所以加上sudo，否则会报出错误

![image-20211201104240816](http://cdn.noteblogs.cn/image-20211201104240816.png)

输出结果中，第一行包含三个数据，分别是采样数Samples、事件类型event、事件总数量Event count，第一列的数据表示该符号的性能时间在所有采样中的比例

另外一种做大是perf record和perf report，perf top的缺点是不能保存数据，也就是无法用于离线或者后续的分析，perf record提供了保存数据的功能，保存后的数据用perf report解析展示

# 案列

下面就以Nginx + PHP的Web服务为案列，来实现当CPU使用率过高的问题后，怎么通过这些工具找出异常的进程，然后利用perf找出引发性能问题的函数

**环境准备**

Ubuntu 20.2 2cpu 4G内存 两台虚拟机，其中一台做web服务器，另外一台做客户端，这里php+nginx的环境就不在过多描述，搭建web服务器访问如下代码页面index.php

```php
<?php
// test only.
$x = 0.0001;
for ($i = 0; $i <= 1000000; $i++) {
  $x += sqrt($x);
}

echo "It works!"
?>
```

在客户端机器上访问，可以访问到正常工作的Web服务器

```shell
gpw@gpw-virtual-machine:~$ curl http://192.168.18.149/case1/app/index.php
```

使用ab工具并发10个请求。总共测试100个请求来测试Nginx的性能

```shell
gpw@gpw-virtual-machine:~$ ab -c 10 -n 100 http://192.168.18.149/case1/app/index.php
```

![image-20211201135223281](http://cdn.noteblogs.cn/image-20211201135223281.png)

可以发现Nginx能承受的每秒平均请求只有39.16这对nginx这种高性能的web服务器来说是很低的，其实我们看到源码的话也会很清除的发现代码中的一个耗时的地方，那么我们现在就是通过工具区定位出那个函数比较耗时

持续增大压力，方便测试

```shell
ab -c 10 -n 10000 http://192.168.18.149/case1/app/index.php
```

使用top命令查看，发现确实是php程序比较耗时，几个pph-fpm进程CPU使用率加起来解决200%，而且us的值也到达94.2

![image-20211201135549965](http://cdn.noteblogs.cn/image-20211201135549965.png)

接着使用perf top -g -p [进程id]

```shell
sudo perf top -g -p 29987
```

![image-20211201135807478](http://cdn.noteblogs.cn/image-20211201135807478.png)

其实到这已经发现了，就是zif_sqrt函数与add_function，这里的函数名也许会和我们在index.php总定义的不一样，因为可能是php内部编译的时候对函数的名字做了改变，但是也能大致的猜测到

现在我们将那几行测试的代码删除，重新使用ab工具进行测试

```php
<?php
// test only.

echo "It works!"
?>
```

```shell
 ab -c 10 -n 100 http://192.168.18.149/case1/app/index.php
```

发现目前的每秒平均请求数已经到了1180了

![image-20211201140157487](http://cdn.noteblogs.cn/image-20211201140157487.png)

CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注
的第一个指标。所以我们更要熟悉它的含义，尤其要弄清楚用户（%user）、
Nice（%nice）、系统（%system） 、等待 I/O（%iowait） 、中断（%irq）以及软中断
（%softirq）这几种不同 CPU 的使用率。比如说：

- 用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进
  程的性能问题。
- 系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用
  的性能问题。
- I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现
  了 I/O 问题。
- 软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重
  排查内核中的中断服务程序  

碰到 CPU 使用率升高的问题，你可以借助 top、pidstat 等工具，确认引发 CPU 性能问题
的来源；再使用 perf 等工具，排查出引起性能问题的具体函数  